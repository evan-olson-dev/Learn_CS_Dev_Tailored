[<- Back to Main README](../README.md)

## 8. Unit Testing with NUnit in .NET

Quality and correctness are vital, especially in applications that might interface with hardware (where mistakes could be costly). **Unit testing** is the practice of writing automated tests for small units of your code (typically at the function or class level) to ensure they work as intended. You mentioned the team uses **NUnit** for testing .NET projects, so we’ll focus on that.

**Why Unit Test?** – Unit tests allow you to verify code behavior quickly and catch regressions when changes are made. By writing tests, you often improve your code design (making it more testable usually makes it more modular and decoupled). Good unit tests give confidence that new changes haven’t broken existing functionality. As you integrate into the team, contributing tests alongside code will likely be expected. Remember: *writing tests helps catch bugs early and saves time in the long run* ([Getting Started With .NET Unit Testing Using NUnit](https://www.infragistics.com/blogs/net-unit-testing-using-nunit/#:~:text=Automated%20unit%20tests%20while%20developing,code%20for%20different%20input%20sets)).

**NUnit Basics:** NUnit is a popular testing framework for .NET:
- A test project is usually a separate project in the solution (often named something like *ProjectName.Tests*). It references the main project or libraries to access the code under test.
- Install **[NUnit](https://www.nuget.org/packages/NUnit/)** (framework) and **[NUnit3TestAdapter](https://www.nuget.org/packages/NUnit3TestAdapter/)** (for running tests in VS) via NuGet in the test project. Visual Studio’s test runner (Test Explorer) will then be able to discover and run NUnit tests. (If you use the template `dotnet new nunit`, it sets this up).
- Writing a test: Create a class (e.g., `SensorServiceTests`). Mark it with `[TestFixture]` (though in NUnit this is optional in newer versions). Write public methods in it and mark each with `[Test]` ([Unit testing C# with NUnit and .NET Core - .NET | Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-nunit#:~:text=The%20%60,method%20is%20a%20test%20method)). Each such method is one unit test. Inside, instantiate the class under test (or use a test fixture setup) and use **Assert** statements to verify behavior. For example: `Assert.AreEqual(expectedValue, actualValue)` will make the test *fail* if the values don’t match.
- **Test Setup/Teardown:** You can annotate methods with `[SetUp]` to run code before each test (commonly used to initialize common objects) and `[TearDown]` to clean up after each test. There’s also `[OneTimeSetUp]`/`[OneTimeTearDown]` for once per fixture.
- **Running tests:** In Visual Studio, open Test Explorer to run tests and see results. NUnit also allows running tests via the command line (`dotnet test`). The output will show which tests passed or failed (and stack traces for failures).
- **Test cases and categories:** NUnit supports parameterized tests via `[TestCase(...)]` attributes, which allow you to run the same test code with different inputs. It also has `[Category]` for grouping tests, but initially you might not need that.

**Approach to Unit Testing:**
- Aim to test the **logic** in ViewModels and Models, not the UI (you won’t unit test XAML code-behind or UI rendering – those are better covered by integration tests or manually). With MVVM, most of your logic sits in ViewModels and services which are perfect for unit testing. For example, if you have a `SensorDataProcessor` class or a method that calculates an average, write tests for those.
- Use **dependency injection** and interfaces to your advantage: If a ViewModel depends on an `ISensorService`, in your tests you can provide a fake implementation of that interface that returns controlled data. This isolates the ViewModel logic. Alternatively, learn to use a **mocking framework** like Moq or NSubstitute to create mock objects for interfaces; these can simulate various scenarios (like sensor returns null, or throws exception) to test how your code handles them.
- Write tests for both **expected behavior** and **edge cases/error conditions**. For instance, a method that converts raw sensor bytes to a value should be tested with normal data and also with extreme or invalid data to ensure it handles them gracefully (perhaps throwing an exception, which you can verify with `Assert.Throws`).
- **NUnit Assertions:** Familiarize with common asserts: `Assert.AreEqual`, `Assert.IsTrue`, `Assert.IsFalse`, `Assert.IsNotNull`, `Assert.Throws` (to check an exception is thrown), etc. These are the mechanisms to validate outcomes. NUnit will mark the test failed if an assertion fails.
- **Organize tests** similar to how code is organized. If you have a class `SensorService`, you might have `SensorServiceTests` with multiple [Test] methods each targeting a specific aspect of `SensorService` (e.g., `GetReading_ReturnsLatestValue`, `GetReading_Throws_WhenNotInitialized`, etc.). Name tests clearly — think of them as specifications of behavior.

**Resources:**

- **(Free)** *Microsoft Learn: Unit testing with NUnit* – Microsoft has an interactive tutorial **“Unit testing C# with NUnit and .NET Core”** ([Unit testing C# with NUnit and .NET Core - .NET | Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-nunit#:~:text=This%20tutorial%20takes%20you%20through,instructions%2C%20see%20Samples%20and%20Tutorials)). It walks you through creating a solution with a class library and a test project, writing some sample functions and tests for them. It’s a great hands-on introduction if you haven’t written tests in .NET before. It also covers using the `dotnet test` CLI and some aspects of NUnit like `[TestFixture]` and `[Test]`.
- **(Free)** *NUnit Documentation:* The official NUnit docs (on docs.nunit.org) detail all the attributes and features. There’s a quick-start that shows a basic example. It’s useful to skim the **Assertions** part of the docs to know what kinds of checks you can do. Also, read about **Constraint Model** of NUnit (fluent assertions like `Assert.That(x, Is.EqualTo(y))`) which you may encounter in team’s tests.
- **(Free)** *Blog/Article – “NUnit Testing Tutorial”:* There are blog posts (like on Infragistics or LambdaTest) that give a complete rundown of NUnit with examples ([Getting Started With .NET Unit Testing Using NUnit - Infragistics](https://www.infragistics.com/blogs/net-unit-testing-using-nunit/#:~:text=Getting%20Started%20With%20,project%20%C2%B7%20Creating%20Test)). For instance, the Infragistics blog by Dhananjay Kumar (Feb 2025) is a good read ([Getting Started With .NET Unit Testing Using NUnit](https://www.infragistics.com/blogs/net-unit-testing-using-nunit/#:~:text=Automated%20unit%20tests%20while%20developing,code%20for%20different%20input%20sets)) as it demonstrates creating a calculator class, writing tests, and using Test Explorer. This mirrors what you will do, just with different classes.
- **(Paid)** *Pluralsight – “Unit Testing in C#” courses:* Pluralsight has a number of courses on unit testing (some using MS Test, some NUnit, some xUnit). Even a general one like “Unit Testing Fundamentals” can be useful to understand how to structure tests, what to test, etc. Additionally, there are courses on **TDD (Test-Driven Development)** if you’re interested in that methodology (writing tests before implementation).
- **(Free)** *Moq library (for mocking):* At some point, especially with hardware interaction, you might need to simulate external dependencies. Moq is a popular free library to create fake implementations at runtime. While not strictly required to start, keep it in mind. There are tutorials on using Moq with NUnit if needed (e.g., “Using Moq in NUnit to test” on DMC’s blog as seen in related posts).

**Hands-On:** Write tests for the practice projects you built. For example, if you have a ViewModel that adds contacts, write a test that when you execute `AddContactCommand`, the contact appears in the list. This might involve faking any services or just calling the underlying method if the command handler calls a method. Another example: if you created a `SensorDataProcessor` class that computes something, write tests for it with sample inputs. If you haven’t got a ready piece to test, try a kata or simple problem – e.g., write a small class to determine if a number is prime, then write NUnit tests for it (this is actually the example in the Microsoft tutorial). This lets you practice the mechanics of setting up a test project and running tests.

Make sure to integrate test running into your routine: run tests via Visual Studio or `dotnet test` after making changes. This will eventually mirror how you run the real project’s test suite to ensure nothing broke. If the team uses a CI pipeline, your tests will also run there, so by running them locally first, you preempt CI failures.

**Milestone:** *Be able to confidently write and run unit tests for new code you develop.* In the team setting, this means if you implement a new feature or fix a bug, you also add the appropriate tests and ensure existing tests still pass. The outcome is that you treat the test project as an integral part of the solution, not an afterthought. When you fix a bug, you might even add a test that would have caught it, to prevent regression. Reaching this level means you’ve embraced the practice of unit testing. It also gives you the skill to evaluate the project’s current tests – reading them can often clarify how certain components are supposed to behave (tests serve as documentation too).