[<- Back to Main README](../README.md)

## 9. Working with NuGet Packages and Internal Libraries

The project you’re joining uses internal NuGet packages, especially for interfacing with custom hardware and sensors. In enterprise projects, it’s common to factor out certain components into separate libraries and distribute them as NuGet packages (even if only used internally). Thus, understanding **NuGet** – the package manager for .NET – and how to work with custom package sources is important.

**What is NuGet?** – *“NuGet is the package manager for .NET. It enables developers to create, share, and consume useful .NET libraries.”* ([NuGet documentation | Microsoft Learn](https://learn.microsoft.com/en-us/nuget/#:~:text=NuGet%20documentation)). A NuGet **package** (.nupkg file) is basically a zip containing compiled DLLs and metadata. Developers publish packages to a feed (like nuget.org or a private server), and other projects can reference those packages to use the functionality without having the source. Using NuGet has the benefit of modularizing code and handling dependency versions.

**Consuming NuGet Packages:** In Visual Studio, you typically add a NuGet package via the *NuGet Package Manager*. This can be done through the GUI (right-click References > Manage NuGet Packages) or through the Package Manager Console (`Install-Package SomePackage`) or `dotnet CLI` (`dotnet add package SomePackage`). When you install a package, it adds references to the included DLLs and downloads them to a global or local package cache. In a .NET 6 project with PackageReference, the packages are listed in the .csproj file (you’ll see `<PackageReference Include="PackageName" Version="X.Y.Z" />` entries).

For **internal packages**, your team likely has a **private NuGet feed**. This could be hosted on GitLab (GitLab has a Package Registry that supports NuGet feeds), Azure Artifacts, Artifactory, or even a simple network folder. Instead of nuget.org, the source URL will be different.

- To use a private feed, you usually have to add its URL to your NuGet configuration. In Visual Studio, you can add a package source under Options > NuGet Package Manager > Package Sources. If authentication is needed (likely for an internal feed), you might need to provide credentials (for GitLab’s feed, typically a personal access token is used). Once the source is added, VS can list and install packages from it.
- If the internal libraries are already installed in the project, you might not have to add them manually; just restore packages. Ensure you have access: you might need to be given a token or permissions for the feed. Check the project’s documentation or ask a team member for the feed setup instructions.
- **Managing versions:** Learn how to update a NuGet package to a newer version using the NuGet UI or CLI. Also know how to check the installed version (in VS’s Packages UI or the project file). If a library update causes issues, sometimes you might need to roll back to a previous version – so understanding how to specify versions is useful.
- **Troubleshooting NuGet:** If a package fails to restore (e.g., you get a compile error that a namespace is missing), it could be due to an incorrect feed configuration or missing credentials. Knowing to run `dotnet restore` with verbosity or looking at VS’s Output (NuGet) can help pinpoint the issue. For internal feeds, network or auth issues are common initial hiccups.

**Private/Internal NuGet Feeds:** Many organizations do not publish proprietary libraries to the public. Instead, they host them privately. NuGet fully supports this scenario:
- *“Instead of making packages publicly available, you might want to release packages to only a limited audience, such as your organization… For all such purposes, NuGet supports setting up private package sources.”* ([Overview of Hosting Your Own NuGet Feeds | Microsoft Learn](https://learn.microsoft.com/en-us/nuget/hosting-packages/overview#:~:text=Instead%20of%20making%20packages%20publicly,org)). The methods include simple file shares, private servers, or built-in services like GitLab’s Package Registry or Azure DevOps Artifacts.
- In your case, since the focus is GitLab, it’s likely the internal libraries are hosted on **GitLab Package Registry**. Each GitLab project can act as a NuGet feed (URL typically looks like `https://gitlab.com/api/v4/projects/<ProjectID>/packages/nuget/index.json` for project-level).
- Using GitLab’s NuGet feed will require creating a personal access token with `read_package_registry` scope and adding the source in NuGet’s config with that token (the GitLab docs detail this process ([NuGet packages in the package registry | GitLab Docs](https://docs.gitlab.com/ee/user/packages/nuget_repository/#:~:text=To%20publish%20and%20install%20packages,a%20source%20for%20your%20packages)) ([NuGet packages in the package registry | GitLab Docs](https://docs.gitlab.com/ee/user/packages/nuget_repository/#:~:text=,on%20your%20group%E2%80%99s%20home%20page))). Once set up, using the packages is the same as any other NuGet.

**Working with Internal Libraries:** Besides just installing them, as a developer you should:
- Read any documentation or API reference they have. Perhaps the team has internal docs for how to use the sensor interface library (if not, you might have to read the code via decompiling or if they provided source).
- Understand the update cycle: Are these packages updated frequently? Does the team commit changes to them or are they maintained by another team? If you need to modify something in an internal library, the process might be to update that library’s code (in its own repo), publish a new NuGet version, and then update the main app to that version.
- **NuGet Package Versioning:** Usually versioning follows semantic versioning (Major.Minor.Patch). An internal library might be at v1.x or similar. If your app needs a new capability in the library, you might coordinate to bump the version. Always ensure the main app is referencing the correct version (some companies even lock versions via a global packages.props). Don’t accidentally update a package version without coordination.

**Resources:**

- **(Free)** *NuGet Documentation (Microsoft):* The official docs cover everything from installation to creating packages. Key pages: **“[Install and use a package (Visual Studio)](https://learn.microsoft.com/en-us/nuget/consume-packages/install-use-packages-visual-studio)”** (step-by-step for adding a NuGet package to a project), and **“Publish to a private feed”** (explains how to set up and publish to various private sources). While you might not publish packages yourself initially, understanding that process can help, especially if you ever need to create a NuGet (maybe for a utility or if contributing to the internal libraries).
- **(Free)** *GitLab Package Registry Docs:* GitLab’s documentation on **NuGet packages in the package registry** ([NuGet packages in the package registry | GitLab Docs](https://docs.gitlab.com/ee/user/packages/nuget_repository/#:~:text=Publish%20NuGet%20packages%20in%20your,use%20them%20as%20a%20dependency)) will be directly relevant if that’s what you use. It covers how to authenticate and set up the feed. They have examples for adding the source via Visual Studio or nuget.config ([NuGet packages in the package registry | GitLab Docs](https://docs.gitlab.com/ee/user/packages/nuget_repository/#:~:text=Add%20the%20package%20registry%20as,a%20source%20for%20NuGet%20packages)) ([NuGet packages in the package registry | GitLab Docs](https://docs.gitlab.com/ee/user/packages/nuget_repository/#:~:text=You%20can%20now%20add%20a,new%20source%20to%20NuGet%20with)). Review this to ensure you have the feed properly configured.
- **(Free)** *NuGet Config and CLI:* Learn about the `nuget.config` file. Sometimes projects include a `NuGet.config` in the repository to configure package sources for all developers. Check if your project has one (it would list the internal feed URL). If not, you’ll add it in your global config. The NuGet docs on `nuget.config` and `dotnet nuget add source` CLI command are useful if you need to script it.
- **(Free)** *Article – “Managing NuGet Packages for Enterprise”:* There are blog posts or Medium articles on best practices for using NuGet in an enterprise setting. They might discuss strategies like internal package repositories, version pinning, etc. While not critical, reading one could give you insight into why things are set up a certain way in your team (for example, they might have a mirror of nuget.org to cache packages, or strict version approvals).
- **(Paid)** *No dedicated paid resource needed specifically for NuGet.* The free docs are usually enough. If anything, some courses on DevOps or .NET might include a module on package management, but you likely won’t need a full course on NuGet.

**Hands-On:** To solidify your understanding, try creating a simple NuGet package yourself (just for learning). For instance, make a small class library (could be something like “MathUtils” with a couple of methods), and then use `dotnet pack` to create a NuGet package. Then create another project and install that package (possibly by setting up a local folder as a NuGet source). This mini exercise will demystify the package creation and consumption process: you’ll see how your library’s version and metadata appear in Visual Studio, how updating the package changes the consumed code, etc. You can even simulate a private feed by using a local folder or a private GitHub feed. Though optional, this experience can help when dealing with the real internal packages (especially if you ever need to fix and republish one).

**Milestone:** *Be capable of managing NuGet dependencies in the project.* This means you can add a new NuGet package (from public or internal source) if needed, update existing ones responsibly, and troubleshoot package restore issues. In context of your project, it ensures you can work with those internal sensor/hardware libraries smoothly – for example, if someone says “Use `SensorToolkit 2.0.0` package for the new device integration,” you’d know how to get that version and update the references. It also implies you understand where that library fits in: e.g., you won’t try to edit the code of a NuGet package directly in your solution (since it’s external), but you know how to call its APIs and maybe read its release notes or documentation for guidance.