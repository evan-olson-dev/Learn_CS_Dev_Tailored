[<- Back to Main README](../README.md)

## 5. Prism MVVM Framework (for WPF)

Now that you have a grasp of MVVM, it’s time to introduce **Prism** – the framework your team uses. Prism is a collection of libraries and guidance from the .NET Foundation (originally from Microsoft patterns & practices) that helps build **modular, maintainable, MVVM-oriented applications** ([
	A Properly Pleasing Primer Tutorial for WPF Prism - Part 1:  Introduction | DMC, Inc.

](https://www.dmcinfo.com/latest-thinking/blog/id/9282/a-properly-pleasing-primer-tutorial-for-wpf-prism--part-1-introduction#:~:text=Prism%20provides%20guidance%20designed%20to,built%20for)). Prism is not the only MVVM framework, but it’s powerful and well-suited for complex WPF apps, especially those that may grow or need a plug-in architecture.

**What Prism Provides:** Prism’s goal is to make it easier to implement MVVM and other good architectural patterns. Key features of Prism include:
- **Bootstrapping/Initialization:** Prism provides a `PrismApplication` base class (or used to use a Bootstrapper) to initialize your application. This sets up things like dependency injection container and region navigation.
- **Modularity:** You can split your app into multiple modules (assemblies) that can be loaded on startup or on demand. This is useful if your app has distinct functional areas (for example, a module for Data Acquisition, another for Data Analysis, etc.). Prism helps register modules and inject their views/services as needed.
- **Regions and View Composition:** Prism introduces the concept of *Regions* – think of them as named placeholders in your UI (e.g., a `<ContentControl>` that is a region). You can inject views into regions, allowing dynamic composition of UI. This is how you can have a shell (main window) that loads different views into a central area based on navigation or user actions. It decouples the shell from specific views.
- **View/ViewModel Locator:** Prism can automatically wire Views and ViewModels. If you follow a naming convention (e.g., your View is `MainView` and ViewModel is `MainViewModel` in the same namespace), Prism’s ViewModelLocator will automatically create and assign the ViewModel as DataContext of the View. This saves boilerplate code.
- **Commands and Events:** Prism provides `DelegateCommand` (an implementation of ICommand) which makes commanding easier (you can pass a lambda for execute and can-execute logic). It also has **CompositeCommands** if you need to tie multiple commands together (useful for global toolbar commands, etc.). Additionally, Prism’s **EventAggregator** is a pub-sub event system for communication between components/viewmodels that don’t directly know about each other (for example, if a hardware sensor raises an event that multiple parts of the UI should respond to, you can publish an event). This helps maintain loose coupling.
- **Dependency Injection (DI) Container:** Prism doesn’t force a specific DI container (it used to support Unity, MEF, etc., and now works with Microsoft’s DI or others). It basically helps register types and resolve them. This means your services (like hardware interfaces) can be registered and easily injected into ViewModels. You don’t have to manually create those connections – the container does it, improving testability and flexibility. (In Prism, you’ll typically register types with a container in the startup).
- **Navigation:** Prism has a built-in navigation framework on top of regions. You can request navigation to a view in a region by view name (or type), and Prism handles showing that view, optionally keeping a journal (for back/forward navigation). This is useful for multi-page apps.
- **Dialogs:** Prism has services for common things like showing dialogs in an MVVM-friendly way (IDialogService).

In summary, Prism is there to handle the “plumbing” of a well-structured WPF app, so you can focus on business logic. It embodies patterns like MVVM, event aggregator, dependency injection, etc., which allow creating *“loosely coupled, modular applications… built to last and built for change.”* ([
	A Properly Pleasing Primer Tutorial for WPF Prism - Part 1:  Introduction | DMC, Inc.

](https://www.dmcinfo.com/latest-thinking/blog/id/9282/a-properly-pleasing-primer-tutorial-for-wpf-prism--part-1-introduction#:~:text=Prism%20provides%20guidance%20designed%20to,built%20for)) Many of these features (like commands, INotifyPropertyChanged support) align exactly with what your app needs (and you would otherwise write yourself). Prism just gives them to you in a consistent package.

**Getting Started with Prism:**
- **Set up a Prism project:** The easiest way is to use the Prism Template Pack (if available in Visual Studio Marketplace) which can create a new WPF Prism application for you. Alternatively, you add Prism via NuGet to an existing WPF project. Key NuGet packages: `Prism.Wpf` (core Prism for WPF) and perhaps `Prism.Unity` or `Prism.DryIoc` depending on the DI container your team uses. The template or documentation will guide the needed setup (like your `App.xaml.cs` should inherit `PrismApplication` and call `InitializeComponent` and register modules).
- **Understand the Shell:** In Prism, the *Shell* is typically the main window of the application. The shell XAML might define regions (e.g., a Menu region, a Content region). Part of Prism setup is to show this shell at startup and initialize regions.
- **Module Loading:** Learn how Prism discovers and loads modules. In Prism 8 (for .NET 6), you might use attribute-based module registration or register in code. Each module will have an initialization class where you register its components (views, viewmodels, services). For example, `SensorModule` might register `ISensorService` and its implementation, and maybe register a view for navigation.
- **Navigation and Regions:** Practice creating two simple views and navigate between them using Prism’s `IRegionManager`. For instance, have a “HomeModule” with a HomeView and a “SettingsModule” with a SettingsView. Use a Region (content control) in Shell to display them. Trigger navigation via a command (perhaps hooked to a menu or buttons). This will demonstrate how Prism loads views into regions dynamically.
- **Dependency Injection with Prism:** If you have an interface `ISensorService` and an implementation that reads from hardware or a simulator, register it with Prism’s container in the App initialization (or Module initialization). Then, in your ViewModel constructor, you can request `ISensorService` via constructor injection. Prism (via the DI container) will automatically provide it. This pattern decouples your ViewModel from concrete implementations and makes unit testing (with mocks) possible.

**Resources:**

- **(Free)** *Prism Official Documentation:* The Prism GitHub has a **documentation site** (prismlibrary.github.io) with up-to-date guides. Key sections to read: **“Prism Library for WPF – Overview”** and **“Getting Started with Prism in WPF”**. These will walk through setting up a basic Prism app and explain concepts like Shell, Bootstrapping, regions, etc. The docs also include an *MVVM Primer* which we mentioned earlier, and advanced topics when you need them.
- **(Free)** *Prism Samples (GitHub):* The Prism team provides a repository of sample applications on GitHub: **PrismLibrary/Prism-Samples-Wpf**. These samples are organized by feature – e.g., there’s a sample for using the EventAggregator, one for Region Navigation, one for Dialogs, etc. It’s recommended to start from the first sample (Bootstrapping) and progress sequentially ([GitHub - PrismLibrary/Prism-Samples-Wpf: Samples that demonstrate how to use various Prism features with WPF](https://github.com/PrismLibrary/Prism-Samples-Wpf#:~:text=Samples%20that%20demonstrate%20how%20to,on%20the%20previous%20sample%27s%20concept)), because each sample builds on the previous concept. By examining these, you can see the minimal code needed to use each Prism feature in isolation. This is a great way to learn by example.
- **(Free)** *“Properly Pleasing Prism Primer” blog series (DMC, Inc.):* This is a three-part blog series that goes through building a Prism application step-by-step (Part 1: Introduction, Part 2: Shell/Bootstrapper, Part 3: Modules). It’s a bit older but still relevant to Prism fundamentals. It explains what Prism is in very approachable terms (including its history and features) ([
	A Properly Pleasing Primer Tutorial for WPF Prism - Part 1:  Introduction | DMC, Inc.

](https://www.dmcinfo.com/latest-thinking/blog/id/9282/a-properly-pleasing-primer-tutorial-for-wpf-prism--part-1-introduction#:~:text=including%20modular%20programming%20support%2C%20event,of%20them%20as%20they%20want)) and then gets hands-on with code. Following along with such a tutorial can solidify how everything ties together (especially the bootstrapper/initialization which can be the trickiest part).
- **(Paid)** *Pluralsight – “Introduction to Prism for WPF” by Brian Lagunas:* Brian Lagunas is one of the maintainers of Prism. His course on Pluralsight is a comprehensive introduction to Prism (covering Prism 7/8). It goes through building a sample app using Prism, demonstrating regions, module loading, navigation, etc., with clear explanations. This is arguably one of the best ways to learn Prism if you have access to Pluralsight, as it’s practically oriented and up-to-date with Prism’s latest version.
- **(Paid)** *“Prism in Practice” or other books:* There may not be a very recent Prism book (most are from the Prism 4 or 5 era), but if you prefer books, search for **“Prism WPF book”**. One example is *“Prism 4 in Action”*, though it’s quite dated and tied to older .NET. You might not need a book given the online resources and your hands-on practice, but it’s worth knowing these exist. Often the official documentation plus sample code is sufficient for Prism.

**Hands-On with Prism:** Create a new branch of your WPF test project to integrate Prism. Alternatively, start a fresh small Prism demo: for instance, a **“Modular Sensor Monitor”** app. The Shell (MainWindow) could have two regions: one for navigation (like a List or Buttons to switch views) and one for content. Implement two modules: *SensorDashboardModule* and *SensorSettingsModule*. The Dashboard view could display a fake sensor reading, and the Settings view could have some settings (like a threshold). Use Prism’s navigation to switch between them. Use an EventAggregator event to simulate broadcasting a sensor value update that multiple components could listen to. While this app is trivial, doing this exercise will make you go through: setting up PrismApplication, registering modules, defining regions in XAML, and navigating – covering the core Prism workflow.

**Milestone:** *Be able to contribute to your team’s Prism application.* After this, you should feel comfortable reading the structure of your real project: identifying modules, understanding how ViewModels are wired via Prism, how navigation is done, etc. You should know how to add a new View + ViewModel following Prism conventions, how to register it, and how to call into shared services via DI. Essentially, Prism’s concepts (regions, commands, DI, events) should not feel mysterious – you’ll know their purpose and usage in your project’s context.