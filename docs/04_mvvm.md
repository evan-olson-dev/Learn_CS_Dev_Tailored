[<- Back to Main README](../README.md)

## 4. Model-View-ViewModel (MVVM) Design Pattern

With WPF basics in hand, it’s crucial to adopt the **MVVM design pattern** for structuring your application. MVVM is the architectural pattern that underpins modern WPF development and is a central concept for the Prism framework. It helps **separate concerns** in your application: the UI (View), the logic/state (ViewModel), and the data/business layer (Model) ([Implementing the MVVM Pattern Using the Prism Library for WPF | Prism ](https://prismlibrary.github.io/docs/wpf/legacy/Implementing-MVVM.html#:~:text=Using%20the%20MVVM%20pattern%2C%20the,application%27s%20business%20logic%20and%20data)). This separation makes your app more maintainable, testable, and collaborative (developers can work on ViewModel logic while designers tweak XAML, etc.).

**What is MVVM?** – In MVVM, you have:
- **Model:** Represents the data or business logic, typically POCO classes or services that retrieve data (e.g., a `SensorReading` class or a data service). Models should be unaware of the UI.
- **View:** The UI layer (XAML plus code-behind for a Window or UserControl). The View’s job is to define the layout and visual aspects. Ideally, the code-behind in the View should be minimal (only UI-specific code that doesn’t belong in ViewModel). The View binds to a ViewModel to get its data.
- **ViewModel:** The intermediary that holds the presentation logic and state for the View. The ViewModel exposes properties (and collections) that the View can data-bind to, and commands that the View can trigger (instead of handling UI events directly). The ViewModel interacts with Models (calls methods, retrieves data) and prepares data for display. Importantly, it implements `INotifyPropertyChanged` to notify the View of property changes, so the UI stays in sync with data.

The **MVVM interaction** is primarily through data binding and commands:
- The View’s `DataContext` is set to an instance of the ViewModel. This means any `{Binding XYZ}` in the XAML will look for an `XYZ` property in the ViewModel. For example, if your ViewModel has a `Temperature` property and the View has a TextBlock with `Text="{Binding Temperature}"`, it will display that value. When the ViewModel updates `Temperature` (and raises PropertyChanged), the UI updates ([Implementing the MVVM Pattern Using the Prism Library for WPF | Prism ](https://prismlibrary.github.io/docs/wpf/legacy/Implementing-MVVM.html#:~:text=In%20WPF%2C%20data%20binding%20expressions,view%20and%20its%20view%20model)).
- User actions (like button clicks) are typically bound to **ICommand** properties in the ViewModel (using XAML `{Binding SaveCommand}` and Button’s `Command` property). This replaces the need for code-behind event handlers and allows the ViewModel to handle the logic in response to UI interactions.
- The ViewModel can also respond to changes in Models or trigger navigation, etc., but at its core, it’s the mediator between View and Model.

**Why MVVM?** – It leads to cleaner separation. You can **unit test** the ViewModel without any UI. It also aligns well with WPF’s data binding. Microsoft designed WPF with MVVM in mind (it’s a “Presentation Model” pattern). Using MVVM, you avoid tightly coupling UI to logic, making it easier to modify one without breaking the other ([Implementing the MVVM Pattern Using the Prism Library for WPF | Prism ](https://prismlibrary.github.io/docs/wpf/legacy/Implementing-MVVM.html#:~:text=Using%20the%20MVVM%20pattern%2C%20the,application%27s%20business%20logic%20and%20data)). In practice, MVVM might feel like extra setup at first (more classes), but for non-trivial apps it pays off with easier maintenance and extension.

**Learn MVVM Step by Step:**
- Start with a simple example: perhaps revisit your “Contact Manager” or a **basic calculator** and refactor it to MVVM. Create a ViewModel (e.g., `ContactManagerViewModel`) that has properties for the form fields and a collection for contacts. Bind the TextBoxes to ViewModel properties instead of using them directly. Implement a command (e.g., `AddContactCommand`) that takes the input and adds a new item to the list. Remove as much logic from code-behind as possible – the code-behind might only initialize the ViewModel and set `DataContext`. This exercise will help you see MVVM in action.
- Implementing **INotifyPropertyChanged**: Write a base ViewModel class that implements this interface (there are many examples online). This base class has a helper method to raise the `PropertyChanged` event. Then your actual ViewModel classes can inherit from it. This is standard in MVVM to reduce boilerplate. (In Prism, you’ll later use its `BindableBase` which already provides this functionality).
- Implementing **ICommand**: Understand that an `ICommand` has an `Execute` and `CanExecute`. A common approach is to use a `RelayCommand` or `DelegateCommand` (Prism provides `DelegateCommand`) where you simply provide the logic to execute. For now, you can either implement a simple `RelayCommand` class (many tutorials show how) or use Prism’s later. The idea is to expose commands from the ViewModel for the UI to bind to.

**Resources:**

- **(Free)** *MVVM Basics – Microsoft Docs or Blogs:* Look for Microsoft’s documentation or blog posts introducing MVVM. For example, the Microsoft Docs (older “Prism” guide or “WPF Model-View-ViewModel toolkit” guidance) discuss the pattern. One core explanation: *“MVVM pattern helps to cleanly separate the business and presentation logic of your application from its UI… The view interacts with the view model through data binding, commands, and notifications.”* ([Implementing the MVVM Pattern Using the Prism Library for WPF | Prism ](https://prismlibrary.github.io/docs/wpf/legacy/Implementing-MVVM.html#:~:text=Using%20the%20MVVM%20pattern%2C%20the,application%27s%20business%20logic%20and%20data)) ([Implementing the MVVM Pattern Using the Prism Library for WPF | Prism ](https://prismlibrary.github.io/docs/wpf/legacy/Implementing-MVVM.html#:~:text=The%20MVVM%20pattern%20is%20a,data%20templates%2C%20commands%2C%20and%20behaviors)). Reading such overviews will reinforce the concepts.
- **(Free)** *Prism Library MVVM Overview:* The Prism documentation itself contains a section *“Implementing the MVVM Pattern”* ([Implementing the MVVM Pattern Using the Prism Library for WPF | Prism ](https://prismlibrary.github.io/docs/wpf/legacy/Implementing-MVVM.html#:~:text=Using%20the%20MVVM%20pattern%2C%20the,application%27s%20business%20logic%20and%20data)) which, despite being in Prism docs, is a great general MVVM explanation. It covers the responsibilities of View, ViewModel, and Model, and how they interact (with diagrams). It’s worth a read to solidify your understanding of the pattern in the context of WPF.
- **(Free)** *MVVM Light Toolkit or Community Blogs:* You might come across references to MVVM frameworks like MVVM Light (by Laurent Bugnion) or others. While you’ll be focusing on Prism, sometimes skimming an article or two about MVVM Light’s usage can give additional perspective on MVVM (since all MVVM frameworks share the same fundamentals). Blogs like those on CodeProject (e.g., “MVVM for Beginners”) or YouTube videos explaining MVVM pattern with a small demo can be helpful.
- **(Paid)** *Pluralsight – “MVVM Fundamentals” or “WPF MVVM” courses:* Pluralsight has specific courses focused on MVVM in WPF. One example is *“WPF MVVM: Introduction to Model-View-ViewModel”*. These courses typically walk through building an app with MVVM, and might introduce a lightweight toolkit. It can be useful to see the pattern applied in a guided way.
- **(Paid)** *“Developer’s Guide to Microsoft Prism” (Book/PDF):* This was an older Microsoft patterns & practices guide (for Prism 4) which covered MVVM concepts as well. Though dated, if you find a PDF, the MVVM chapters are still relevant. Alternatively, **“Advanced MVVM”** by Josh Smith (an expert in WPF) is a PDF/book often recommended for deep MVVM insights (though possibly beyond beginner needs).

**Milestone:** *Apply MVVM to a simple WPF feature.* You should reach a point where given a new UI requirement, you naturally think in terms of “What’s the ViewModel? What are the Model classes? How will the View bind to the VM?” For example, if asked to create a form that controls some hardware (e.g., a pump on/off, with a reading of current pressure), you’d identify the need for a `PumpViewModel` with properties like `IsPumpOn` and `Pressure`, a command `TogglePumpCommand`, and a service Model that actually interfaces with the hardware. Achieving this mindset means you’re ready to leverage Prism to streamline MVVM in larger apps.